线程的生命周期
	新建状态
		当一个线程对象被创建，还未调用start()方法，（仅仅是一个普通的java对象，在堆栈中分配空间）
			Thread t = new Thread();
			此时t对象就处于新建状态。
				如果AA类继承了Thread类，也就是说AA是Thread类的子类。
				那此时，AA aa = new AA();此时aa也是处于新建状态的线程对象。
				
	可运行状态：表示当前线程已经启动
		当一个线程对象，调用了start()方法，此时该线程处于可运行状态。
		
		可运行状态包含：就绪和运行两种状态。
			就绪（ready）：表明当前线程没有被cpu的线程调度器所调度，但是此时已经做好了准备，随时可以运行。
			运行（running）：表示当前正在被cpu调度，正在被执行。
	
	阻塞（blocked）：正在被运行的某个线程遇到某种特殊情况，同步，等待I/O操作完成后也会进入阻塞。
		阻塞状态转换为运行状态，也并不是立马就运行，目前处于就绪状态之中，需要有cpu调度来分配执行。
		
	无限等待(wait)：当线程中使用了wait方法，此时当前线程进入无线等待。
		除非，其他线程调用notify()或notifyAll()方法，方可唤醒等待的线程。
			（具体案例看生产者和消费者案例）
	
	计时等待(timed-waiting)：当线程中使用了wait(long time)方法，或者使用了sleep(long time)方法。
		当计时时间一到，就会重新进入可运行状态。
		
	终止状态(terminated)：也称为死亡状态：当线程执行完毕，或者执行的过程中出现了异常。
		线程一旦死亡，就不能重新被启动。若启动，会报错，java.lang.IllegalThreadStateException
		在Thread类中有一方法isAlive()，这个方法是用来判断线程是否处于活动状态。
		
控制线程：
	联合线程：
		线程的join方法，表示一个线程等待另一个线程完成后才执行，称之为联合线程，就是说把当前线程和当前线程所在的线程联合成一个线程。join方法被调用后，线程对象处于阻塞状态。
		联合线程适用于A线程需要等到B线程执行完毕，再拿B线程的结果继续运行A线程。
			通俗来说就是：A线程需要拿到B线程的执行结果，才能继续往下。
			
	后台线程：在后台运行，其目的是为其他线程提供服务，也称为“守护线程”
		其中JVM的垃圾回收器就是典型的后台线程。
		特点：当所有的前台线程都死亡，后台线程自动死亡。
		前台线程创建的线程默认为前台线程,当且仅当创建线程是后台线程时，新线程才是后台线程。
		
		设置后台线程：Thread.setDaemon(true),该方法必须在start()方法启动之前设置，否则报 java.lang.IllegalStateException
		
线程的优先级：
	每个线程都有优先级，优先级的高低只和获取CPU的时间片段的机会有关。
		并不是优先级越高，就一定先执行。具体哪个线程先执行取决于CPU的调度。
	设置优先级：void setPriority(int newPriority) 更改线程的优先级
	获取优先级：int getPriority() 返回线程的优先级
	线程的最高优先级为10，最低为1，默认为5

线程中的礼让：
	yield():该方法会给相同等级或更高等级的线程运行的机会
	
定时器：（java.util.Timer）:可以安排任务执行一次，或者定期重复执行。
	//需求：3秒后输出Hello
	//每隔1秒钟，输出当前系统时间